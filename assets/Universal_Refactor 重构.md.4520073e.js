import{_ as r,c as t,o as e,a as n}from"./app.36aa1ef3.js";const u=JSON.parse('{"title":"Refactor 重构","description":"","frontmatter":{"title":"Refactor 重构","created_at":"2022-05-21T13:40:54.000Z","updated_at":"2022-11-06T01:24:41.000Z","word_count":1512},"headers":[{"level":2,"title":"代码的坏味道","slug":"代码的坏味道","link":"#代码的坏味道","children":[]},{"level":2,"title":"常用重构","slug":"常用重构","link":"#常用重构","children":[]},{"level":2,"title":"封装","slug":"封装","link":"#封装","children":[]},{"level":2,"title":"搬移特性","slug":"搬移特性","link":"#搬移特性","children":[]},{"level":2,"title":"重新组织数据","slug":"重新组织数据","link":"#重新组织数据","children":[]},{"level":2,"title":"简化条件逻辑","slug":"简化条件逻辑","link":"#简化条件逻辑","children":[]},{"level":2,"title":"重构API","slug":"重构api","link":"#重构api","children":[]},{"level":2,"title":"处理继承关系","slug":"处理继承关系","link":"#处理继承关系","children":[]}],"relativePath":"Universal/Refactor 重构.md"}'),o={name:"Universal/Refactor 重构.md"},s=n('<p>重构</p><blockquote><p>不改变软件系统外部行为的前提下，改善它的内部结构</p></blockquote><p>重构过程的精髓：<strong>小步修改，每次修改后就运行测试</strong></p><p>重构的目的</p><ol><li>重构改进软件的设计：消除重复代码</li><li>重构使软件更容易理解：理解并不只是对计算机，还应该是对另一个程序员，或者未来的你自己。</li><li>重构帮助找到bug：更加深入的理解代码的所作所为</li><li>重构提高编程速度：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间的保持开发的快速。</li></ol><p><a href="https://github.com/HugoMatilla/Refactoring-Summary" target="_blank" rel="noreferrer">Refactoring-Summary</a></p><h2 id="代码的坏味道" tabindex="-1">代码的坏味道 <a class="header-anchor" href="#代码的坏味道" aria-hidden="true">#</a></h2><p>1.　神秘命名（Mysterious Name) <br> 2.　重复代码（Duplicated Code) <br> 3.　过长函数（Long Function) 函数中的代码行数原则上不要超过 100 行 <br> 4.　过长参数列表（Long Parameter List) <br> 5.　全局数据（Global Data) <br> 6.　可变数据（Mutable Data) <br> 7.　<strong>发散式变化（Divergent Change)</strong> 一个类受多种变化的影响 <br> 8.　<strong>霰弹式修改（Shotgun Surgery)</strong> 多种变化引发多个类相应的修改 <br> 9.　<strong>依恋情结（Feature Envy)</strong> 一个函数访问其它对象的数据比访问自己的数据更多 <br> 10.　<strong>数据泥团（Data Clumps)</strong> 代码的不同部分包含相同的变量组 <br> 11.　<strong>基本类型偏执（Primitive Obsession)</strong></p><ul><li><p>使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。</p></li><li><p>使用常量编码信息（例如一个用于引用管理员权限的常量USER_ADMIN_ROLE = 1 ）。</p></li><li><p>使用字符串常量作为字段名在数组中使用。</p><p><br> <strong>12.　重复的switch（Repeated Switches) <br> 13.　循环语句（Loops) <br> 14.　冗赘的元素（Lazy Element) <br> 15.　夸夸其谈通用性（Speculative Generality) <strong>存在未被使用的类、函数、字段或参数</strong> <br> 16.　临时字段（Temporary Field) <br> 17.　过长的消息链（Message Chains) <br> 18.　中间人（Middle Man) <strong>类本身成了一个空壳，除了委托之外不做任何事情</strong> <br> 19.　内幕交易（Insider Trading) <strong>一个类大量使用另一个类的内部字段和方法</strong> <br> 20.　过大的类（Large Class) <br> 21.　异曲同工的类（Alternative Classes with Different Interfaces) ** <br> 两个类中有着不同的函数，却在做着同一件事。</strong> <br> 22.　纯数据类（Data Class) <strong>只包含字段和访问它们的 getter 和 setter 函数的类</strong> <br> 23.　被拒绝的遗赠（Refused Bequest) <strong>子类仅仅使用父类中的部分方法和属性，其他来自父类的馈赠成为了累赘。</strong> <br> 24.　注释（Comments) **最好的注释是为函数或类起一个恰当的名字</p></li></ul><h2 id="常用重构" tabindex="-1">常用重构 <a class="header-anchor" href="#常用重构" aria-hidden="true">#</a></h2><p><strong>1.　提炼函数（Extract Function)</strong> <br> <strong>2.　内联函数（Inline Function)</strong> <br> <strong>3.　提炼变量（Extract Variable)</strong> <br> <strong>4.　内联变量（Inline Variable)</strong> <br> <strong>5.　改变函数声明（Change Function Declaration)</strong> <br> <strong>6.　封装变量（Encapsulate Variable)</strong> <br> <strong>7.　变量改名（Rename Variable)</strong> <br> <strong>8.　引入参数对象（Introduce Parameter Object)</strong> <br> <strong>9.　函数组合成类（Combine Functions into Class)</strong> <br> <strong>10.　函数组合成变换（Combine Functions into Transform)</strong> <br> <strong>11.　拆分阶段（Split Phase)</strong></p><h2 id="封装" tabindex="-1">封装 <a class="header-anchor" href="#封装" aria-hidden="true">#</a></h2><p><strong>1.　封装记录（Encapsulate Record)</strong> <br> <strong>2.　封装集合（Encapsulate Collection)</strong> <br> <strong>3.　以对象取代基本类型（Replace Primitive with Object)</strong> <br> <strong>4.　以查询取代临时变量（Replace Temp with Query)</strong> <br> <strong>5.　提炼类（Extract Class)</strong> <br> <strong>6.　内联类（Inline Class)</strong> <br> <strong>7.　隐藏委托关系（Hide Delegate)</strong> <br> <strong>8.　移除中间人（Remove Middle Man)</strong> <br> <strong>9.　替换算法（Substitute Algorithm)</strong></p><h2 id="搬移特性" tabindex="-1">搬移特性 <a class="header-anchor" href="#搬移特性" aria-hidden="true">#</a></h2><p><strong>1.　搬移函数（Move Function)</strong> <br> <strong>2.　搬移字段（Move Field)</strong> <br> <strong>3.　搬移语句到函数（Move Statements into Function)</strong> <br> <strong>4.　搬移语句到调用者（Move Statements to Callers)</strong> <br> <strong>5.　以函数调用取代内联代码（Replace Inline Code with Function Call)</strong> <br> <strong>6.　移动语句（Slide Statements)</strong> <br> <strong>7.　拆分循环（Split Loop)</strong> <br> <strong>8.　以管道取代循环（Replace Loop with Pipeline)</strong> <br> <strong>9.　移除死代码（Remove Dead Code)</strong></p><h2 id="重新组织数据" tabindex="-1">重新组织数据 <a class="header-anchor" href="#重新组织数据" aria-hidden="true">#</a></h2><p><strong>1.　拆分变量（Split Variable)</strong> <br> <strong>2.　字段改名（Rename Field)</strong> <br> <strong>3.　以查询取代派生变量（Replace Derived Variable with Query)</strong> <br> <strong>4.　将引用对象改为值对象（Change Reference to Value)</strong> <br> <strong>5.　将值对象改为引用对象（Change Value to Reference)</strong></p><h2 id="简化条件逻辑" tabindex="-1">简化条件逻辑 <a class="header-anchor" href="#简化条件逻辑" aria-hidden="true">#</a></h2><p><strong>1.　分解条件表达式（Decompose Conditional)</strong> <br> <strong>2.　合并条件表达式（Consolidate Conditional Expression)</strong> <br> <strong>3.　以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses)</strong> <br> <strong>4.　以多态取代条件表达式（Replace Conditional with Polymorphism)</strong> <br> <strong>5.　引入特例（Introduce Special Case)</strong> <br> <strong>6.　引入断言（Introduce Assertion)</strong></p><h2 id="重构api" tabindex="-1">重构API <a class="header-anchor" href="#重构api" aria-hidden="true">#</a></h2><p><strong>1.　将查询函数和修改函数分离（Separate Query from Modifier)</strong> <br> <strong>2.　函数参数化（Parameterize Function)</strong> <br> <strong>3.　移除标记参数（Remove Flag Argument)</strong> <br> <strong>4.　保持对象完整（Preserve Whole Object)</strong> <br> <strong>5.　以查询取代参数（Replace Parameter with Query)</strong> <br> <strong>6.　以参数取代查询（Replace Query with Parameter)</strong> <br> <strong>7.　移除设值函数（Remove Setting Method)</strong> <br> <strong>8.　以工厂函数取代构造函数（Replace Constructor with Factory Function)</strong> <br> <strong>9.　以命令取代函数（Replace Function with Command)</strong> <br> <strong>10.　以函数取代命令（Replace Command with Function)</strong></p><h2 id="处理继承关系" tabindex="-1">处理继承关系 <a class="header-anchor" href="#处理继承关系" aria-hidden="true">#</a></h2><p><strong>1.　函数上移（Pull Up Method)</strong> <br> <strong>2.　字段上移（Pull Up Field)</strong> <br> <strong>3.　构造函数本体上移（Pull Up Constructor Body)</strong> <br> <strong>4.　函数下移（Push Down Method)</strong> <br> <strong>5.　字段下移（Push Down Field)</strong> <br> <strong>6.　以子类取代类型码（Replace Type Code with Subclasses)</strong> <br> <strong>7.　移除子类（Remove Subclass)</strong> <br> <strong>8.　提炼超类（Extract Superclass)</strong> <br> <strong>9.　折叠继承体系（Collapse Hierarchy)</strong> <br> <strong>10.　以委托取代子类（Replace Subclass with Delegate)</strong> <br> <strong>11.　以委托取代超类（Replace Superclass with Delegate)</strong></p>',23),a=[s];function i(l,g,c,b,d,h){return e(),t("div",null,a)}const m=r(o,[["render",i]]);export{u as __pageData,m as default};
