import{_ as t,o as r,c as e,Q as a}from"./chunks/framework.1f7d9302.js";const f=JSON.parse('{"title":"Redis","description":"","frontmatter":{"title":"Redis","created_at":"2022-02-01T05:44:46.000Z","updated_at":"2023-07-02T08:32:51.000Z","word_count":5459},"headers":[],"relativePath":"CS/Redis.md","filePath":"CS/Redis.md"}'),d={name:"CS/Redis.md"},i=a('<h2 id="——-redis-——" tabindex="-1">—— <a href="https://github.com/redis/redis" target="_blank" rel="noreferrer">Redis</a> —— <a class="header-anchor" href="#——-redis-——" aria-label="Permalink to &quot;—— [Redis](https://github.com/redis/redis) ——&quot;">​</a></h2><p>Remote Dictionary Server（远程字典服务器）</p><p>由Salvatore Sanfilippo编写的key-value存储系统。 <br> 一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p><strong>使用场景</strong></p><ul><li><strong>缓存</strong> - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</li><li><strong>计数器</strong> - Redis 这种内存数据库能支持计数器频繁的读写操作。</li><li><strong>应用限流</strong> - 限制一个网站访问流量。</li><li><strong>消息队列</strong> - 使用 List 数据类型，它是双向链表。</li><li><strong>查找表</strong> - 使用 HASH 数据类型。</li><li><strong>交集运算</strong> - 使用 SET 类型，例如求两个用户的共同好友。</li><li><strong>排行榜</strong> - 使用 ZSET 数据类型。</li><li><strong>分布式 Session</strong> - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</li><li><strong>分布式锁</strong> - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</li></ul><p><strong>特性</strong></p><ul><li>丰富的数据类型，数据结构简单</li><li>单个操作是原子性的。多个操作也支持事务</li><li>持久化：可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>基于内存操作</li><li>使用 I/O 多路复用模型</li></ul><p>数据淘汰策略</p><ul><li>noeviction - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。默认策略</li><li>allkeys-lru - 在主键空间中，优先移除最近未使用的 key。</li><li>allkeys-random - 在主键空间中，随机移除某个 key。</li><li>volatile-lru - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li><li>volatile-random - 在设置了过期时间的键空间中，随机移除某个 key。</li><li>volatile-ttl - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li></ul><p><strong>Redis架构</strong></p><ul><li>redis-cli：客户端</li><li>redis-server：服务器</li><li>redis-check-dump：本地数据库检查</li><li>redis-check-aof：更新日志检查（Append-only file）</li><li>redis-benchmark：性能测试，用以模拟同时由N个客户端发送M个 SETs/GETs 查询</li></ul><p><code>redis-cli -h host -p port -a password</code></p><ul><li>设置密码：CONFIG set requirepass &quot;password&quot;</li><li>查看密码：CONFIG get requirepass</li><li>验证密码：AUTH password</li></ul><p><strong>连接</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/connection_auth.html" target="_blank" rel="noreferrer">AUTH password</a></td><td>使用给定的密码验证服务器</td></tr><tr><td><a href="http://www.yiibai.com/redis/connection_echo.html" target="_blank" rel="noreferrer">ECHO message</a></td><td>打印给定的字符串信息</td></tr><tr><td><a href="http://www.yiibai.com/redis/connection_ping.html" target="_blank" rel="noreferrer">PING</a></td><td>检查服务器是否正在运行</td></tr><tr><td><a href="http://www.yiibai.com/redis/connection_quit.html" target="_blank" rel="noreferrer">QUIT</a></td><td>关闭当前连接</td></tr><tr><td><a href="http://www.yiibai.com/redis/connection_select.html" target="_blank" rel="noreferrer">SELECT index</a></td><td>更改当前连接的所选数据库</td></tr></tbody></table><p>性能测试：<code>redis-benchmark [option] [option value]</code></p><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td><strong>-h</strong></td><td>指定服务器主机名</td><td>127.0.0.1</td></tr><tr><td><strong>-p</strong></td><td>指定服务器端口</td><td>6379</td></tr><tr><td><strong>-s</strong></td><td>指定服务器套接字</td><td></td></tr><tr><td><strong>-c</strong></td><td>指定并行连接的数量</td><td>50</td></tr><tr><td><strong>-n</strong></td><td>指定请求的总数</td><td>10000</td></tr><tr><td><strong>-d</strong></td><td>指定SET/GET值的数据大小(以字节为单位)</td><td>2</td></tr><tr><td><strong>-k</strong></td><td>1=keep alive, 0=reconnect</td><td>1</td></tr><tr><td><strong>-r</strong></td><td>使用SET/GET/INCR的随机键，SADD的随机值</td><td></td></tr><tr><td><strong>-p</strong></td><td>管道<code>&lt;numreq&gt;</code>请求</td><td>1</td></tr><tr><td><strong>-h</strong></td><td>指定服务器主机名</td><td></td></tr><tr><td><strong>-q</strong></td><td>强制让Redis安装。 只显示query/sec值</td><td></td></tr><tr><td><strong>--csv</strong></td><td>以CSV格式输出</td><td></td></tr><tr><td><strong>-l</strong></td><td>生成循环，永久运行测试</td><td></td></tr><tr><td><strong>-t</strong></td><td>只运行逗号分隔的测试列表</td><td></td></tr><tr><td><strong>-I</strong></td><td>空闲模式。 只打开N个空闲连接并等待</td><td></td></tr></tbody></table><p>示例：<code>redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q</code></p><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><table><thead><tr><th>数据类型</th><th>数据类型存储的值</th><th>说 明</th></tr></thead><tbody><tr><td>STRING <br> （字符串）</td><td>字符串、整数和浮点数</td><td>对字符串进行操作，如增加字符或者求子串：如果是整数或者浮点数，可以计算，如自增等</td></tr><tr><td>LIST <br> （列表）</td><td>一个链表，它的每一个节点都包含一个字符串</td><td>可以在链表的两端插入或者弹出节点，或者通过偏移对它进行裁剪；还可以读取一个或者多个节点，根据条件删除或者查找节点等</td></tr><tr><td>SET <br> （集合）</td><td>无序集合，每一个元素都是一个字符串</td><td>可以新增、读取、删除单个元素：检测一个元素是否在集合中；进行集合的运算；随机从集合中读取元素</td></tr><tr><td>HASH <br> （哈希散列表）</td><td>一个键值对应的无序列表</td><td>可以増、删、査、改单个键值对，也可以获取所有的键值对</td></tr><tr><td>ZSET <br> （有序集合）</td><td>有序的集合，可包含字符 串、整数、浮点数、分值（score），排序是依据分值的大小来决定的</td><td>可以增、删、査、改元素，根据分值的范围或者成员來获取对应的元索</td></tr><tr><td>HyperLogLog <br> （基数）</td><td>计算重复的值，以确定存储的数量</td><td>只提供基数的运算，不提供返回的功能</td></tr></tbody></table><h2 id="命令" tabindex="-1">命令 <a class="header-anchor" href="#命令" aria-label="Permalink to &quot;命令&quot;">​</a></h2><h3 id="基本命令" tabindex="-1">基本命令 <a class="header-anchor" href="#基本命令" aria-label="Permalink to &quot;基本命令&quot;">​</a></h3><p><code>help &lt;command&gt;</code> 查看帮助</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/keys_del.html" target="_blank" rel="noreferrer">DEL key</a></td><td>此命令删除一个指定键(如果存在)。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_dump.html" target="_blank" rel="noreferrer">DUMP key</a></td><td>此命令返回存储在指定键的值的序列化版本。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_exists.html" target="_blank" rel="noreferrer">EXISTS key</a></td><td>此命令检查键是否存在。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_keys.html" target="_blank" rel="noreferrer">KEYS pattern</a></td><td>查找与指定模式匹配的所有键。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_move.html" target="_blank" rel="noreferrer">MOVE key db</a></td><td>将键移动到另一个数据库。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_randomkey.html" target="_blank" rel="noreferrer">RANDOMKEY</a></td><td>从Redis返回一个随机的键。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_rename.html" target="_blank" rel="noreferrer">RENAME key newkey</a></td><td>更改键的名称。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_renamenx.html" target="_blank" rel="noreferrer">RENAMENX key newkey</a></td><td>如果新键不存在，重命名键。</td></tr><tr><td><a href="http://www.yiibai.com/redis/keys_type.html" target="_blank" rel="noreferrer">TYPE key</a></td><td>返回存储在键中的值的数据类型。</td></tr><tr><td>SORT source-key [BY pattern] [LIMIT offset count] [GET pattern ...] [ASC | DESC] [ALPHA] [STORE dest-key]</td><td>对输入 LIST、SET、ZSET 进行排序，然后返回或存储排序的结果。</td></tr><tr><td>clear</td><td>清屏</td></tr></tbody></table><h3 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to &quot;String&quot;">​</a></h3><table><thead><tr><th>命令</th><th>描述说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/strings_set.html" target="_blank" rel="noreferrer">SET key value</a></td><td>设置或更改指定键的值。</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_get.html" target="_blank" rel="noreferrer">GET key</a></td><td>获取指定键的值。</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_setnx.html" target="_blank" rel="noreferrer">SETNX key value</a></td><td>设置键的值，仅当键不存在时</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_mset.html" target="_blank" rel="noreferrer">MSET key value [key value …]</a></td><td>为多个键分别设置它们的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_msetnx.html" target="_blank" rel="noreferrer">MSETNX key value [key value …]</a></td><td>为多个键分别设置它们的值，仅当键不存在时</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_mget.html" target="_blank" rel="noreferrer">MGET key1 [key2..]</a></td><td>获取所有给定键的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_getrange.html" target="_blank" rel="noreferrer">GETRANGE key start end</a></td><td>获取存储在键上的字符串的子字符串。</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_getset.html" target="_blank" rel="noreferrer">GETSET key value</a></td><td>设置键的字符串值并返回其旧值。</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_strlen.html" target="_blank" rel="noreferrer">STRLEN key</a></td><td>获取存储在键中的值的长度</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_incr.html" target="_blank" rel="noreferrer">INCR key</a></td><td>将键的整数值增加1</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_incrby.html" target="_blank" rel="noreferrer">INCRBY key increment</a></td><td>将键的整数值按给定的数值增加</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_incrbyfloat.html" target="_blank" rel="noreferrer">INCRBYFLOAT key increment</a></td><td>将键的浮点值按给定的数值增加</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_decr.html" target="_blank" rel="noreferrer">DECR key</a></td><td>将键的整数值减1</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_decrby.html" target="_blank" rel="noreferrer">DECRBY key decrement</a></td><td>按给定数值减少键的整数值</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_append.html" target="_blank" rel="noreferrer">APPEND key value</a></td><td>将指定值附加到键</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_getbit.html" target="_blank" rel="noreferrer">GETBIT key offset</a></td><td>返回在键处存储的字符串值中偏移处的位值。</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_setbit.html" target="_blank" rel="noreferrer">SETBIT key offset value</a></td><td>存储在键上的字符串值中设置或清除偏移处的位</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_setrange.html" target="_blank" rel="noreferrer">SETRANGE key offset value</a></td><td>在指定偏移处开始的键处覆盖字符串的一部分</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_setex.html" target="_blank" rel="noreferrer">SETEX key seconds value</a></td><td>使用键和到期时间来设置值</td></tr><tr><td><a href="http://www.yiibai.com/redis/strings_psetex.html" target="_blank" rel="noreferrer">PSETEX key milliseconds value</a></td><td>设置键的值和到期时间(以毫秒为单位)</td></tr></tbody></table><h3 id="hash" tabindex="-1">Hash <a class="header-anchor" href="#hash" aria-label="Permalink to &quot;Hash&quot;">​</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/hashes_hdel.html" target="_blank" rel="noreferrer">HDEL key field2 [field2]</a></td><td>删除一个或多个哈希字段。</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hexists.html" target="_blank" rel="noreferrer">HEXISTS key field</a></td><td>判断是否存在散列字段。</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hget.html" target="_blank" rel="noreferrer">HGET key field</a></td><td>获取存储在指定键的哈希字段的值。</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hgetall.html" target="_blank" rel="noreferrer">HGETALL key</a></td><td>获取存储在指定键的哈希中的所有字段和值</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hincrby.html" target="_blank" rel="noreferrer">HINCRBY key field increment</a></td><td>将哈希字段的整数值按给定数字增加</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hincrbyfloat.html" target="_blank" rel="noreferrer">HINCRBYFLOAT key field increment</a></td><td>将哈希字段的浮点值按给定数值增加</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hkeys.html" target="_blank" rel="noreferrer">HKEYS key</a></td><td>获取哈希中的所有字段</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hlen.html" target="_blank" rel="noreferrer">HLEN key</a></td><td>获取散列中的字段数量</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hmget.html" target="_blank" rel="noreferrer">HMGET key field1 [field2]</a></td><td>获取所有给定哈希字段的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hmset.html" target="_blank" rel="noreferrer">HMSET key field1 value1 [field2 value2 ]</a></td><td>为多个哈希字段分别设置它们的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hset.html" target="_blank" rel="noreferrer">HSET key field value</a></td><td>设置散列字段的字符串值</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hsetnx.html" target="_blank" rel="noreferrer">HSETNX key field value</a></td><td>仅当字段不存在时，才设置散列字段的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/hashes_hvals.html" target="_blank" rel="noreferrer">HVALS key</a></td><td>获取哈希中的所有值</td></tr></tbody></table><h3 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to &quot;List&quot;">​</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/lists_blpop.html" target="_blank" rel="noreferrer">BLPOP key1 [key2 ] timeout</a></td><td>删除并获取列表中的第一个元素，或阻塞，直到有一个元素可用</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_brpop.html" target="_blank" rel="noreferrer">BRPOP key1 [key2 ] timeout</a></td><td>删除并获取列表中的最后一个元素，或阻塞，直到有一个元素可用</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_brpoplpush.html" target="_blank" rel="noreferrer">BRPOPLPUSH source destination timeout</a></td><td>从列表中弹出值，将其推送到另一个列表并返回它; 或阻塞，直到一个可用</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lindex.html" target="_blank" rel="noreferrer">LINDEX key index</a></td><td>通过其索引从列表获取元素</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_linsert.html" target="_blank" rel="noreferrer">LINSERT key BEFORE/AFTER pivot value</a></td><td>在列表中的另一个元素之前或之后插入元素</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_llen.html" target="_blank" rel="noreferrer">LLEN key</a></td><td>获取列表的长度</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lpop.html" target="_blank" rel="noreferrer">LPOP key</a></td><td>删除并获取列表中的第一个元素</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lpush.html" target="_blank" rel="noreferrer">LPUSH key value1 [value2]</a></td><td>将一个或多个值添加到列表</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lpushx.html" target="_blank" rel="noreferrer">LPUSHX key value</a></td><td>仅当列表存在时，才向列表添加值</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lrange.html" target="_blank" rel="noreferrer">LRANGE key start stop</a></td><td>从列表中获取一系列元素</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lrem.html" target="_blank" rel="noreferrer">LREM key count value</a></td><td>从列表中删除元素</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_lset.html" target="_blank" rel="noreferrer">LSET key index value</a></td><td>通过索引在列表中设置元素的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_ltrim.html" target="_blank" rel="noreferrer">LTRIM key start stop</a></td><td>修剪列表的指定范围</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_rpop.html" target="_blank" rel="noreferrer">RPOP key</a></td><td>删除并获取列表中的最后一个元素</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_rpoplpush.html" target="_blank" rel="noreferrer">RPOPLPUSH source destination</a></td><td>删除列表中的最后一个元素，将其附加到另一个列表并返回</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_rpush.html" target="_blank" rel="noreferrer">RPUSH key value1 [value2]</a></td><td>将一个或多个值附加到列表</td></tr><tr><td><a href="http://www.yiibai.com/redis/lists_rpushx.html" target="_blank" rel="noreferrer">RPUSHX key value</a></td><td>仅当列表存在时才将值附加到列表</td></tr></tbody></table><h3 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/sets_sadd.html" target="_blank" rel="noreferrer">SADD key member1 [member2]</a></td><td>将一个或多个成员添加到集合</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_scard.html" target="_blank" rel="noreferrer">SCARD key</a></td><td>获取集合中的成员数</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sdiff.html" target="_blank" rel="noreferrer">SDIFF key1 [key2]</a></td><td>减去多个集合</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sdiffstore.html" target="_blank" rel="noreferrer">SDIFFSTORE destination key1 [key2]</a></td><td>减去多个集并将结果集存储在键中</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sinter.html" target="_blank" rel="noreferrer">SINTER key1 [key2]</a></td><td>相交多个集合</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sinterstore.html" target="_blank" rel="noreferrer">SINTERSTORE destination key1 [key2]</a></td><td>交叉多个集合并将结果集存储在键中</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sismember.html" target="_blank" rel="noreferrer">SISMEMBER key member</a></td><td>判断确定给定值是否是集合的成员</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_smove.html" target="_blank" rel="noreferrer">SMOVE source destination member</a></td><td>将成员从一个集合移动到另一个集合</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_spop.html" target="_blank" rel="noreferrer">SPOP key</a></td><td>从集合中删除并返回随机成员</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_srandmember.html" target="_blank" rel="noreferrer">SRANDMEMBER key [count]</a></td><td>从集合中获取一个或多个随机成员</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_srem.html" target="_blank" rel="noreferrer">SREM key member1 [member2]</a></td><td>从集合中删除一个或多个成员</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sunion.html" target="_blank" rel="noreferrer">SUNION key1 [key2]</a></td><td>添加多个集合</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sunionstore.html" target="_blank" rel="noreferrer">SUNIONSTORE destination key1 [key2]</a></td><td>添加多个集并将结果集存储在键中</td></tr><tr><td><a href="http://www.yiibai.com/redis/sets_sscan.html" target="_blank" rel="noreferrer">SSCAN key cursor [MATCH pattern] [COUNT count]</a></td><td>递增地迭代集合中的元素</td></tr></tbody></table><h3 id="sorted-set" tabindex="-1">Sorted set <a class="header-anchor" href="#sorted-set" aria-label="Permalink to &quot;Sorted set&quot;">​</a></h3><table><thead><tr><th>命 令</th><th>说 明</th></tr></thead><tbody><tr><td>zadd key score1 value1 [score2 value2......]</td><td>向有序集合的 key，增加一个或者多个成员</td></tr><tr><td>zcard key</td><td>获取有序集合的成员数</td></tr><tr><td>zcount key min max</td><td>根据分数返回对应的成员列表</td></tr><tr><td>zincrby key increment member</td><td>给有序集合成员值为 member 的分数增加 increment</td></tr><tr><td>zinterstore desKey numkeys key1 [key2 key3......]</td><td>求多个有序集合的交集，并且将结果保存到 desKey 中</td></tr><tr><td>zlexcount key min max</td><td>求有序集合 key 成员值在 min 和 max 的范围</td></tr><tr><td>zrange key start stop [withscores]</td><td>按照分值的大小（从小到大）返回成员，加入 start 和 stop 参数可以截取某一段返回。输入withscores，则连同分数一起返回</td></tr><tr><td>zrank key member</td><td>按从小到大求有序集合的排行</td></tr><tr><td>zrangebylex key min max [limit offset count]</td><td>根据值的大小，从小到大排序，min 为最小值，max 为最大值；limit 选项可选，当 Redis 求出范围集合后，会生产下标 0 到 n，根据 offset 和限定返回数 count，返回对应的成员</td></tr><tr><td>zrangebyscore key min max [withscores] [limit offset count]</td><td>根据分数大小，从小到大求取范围，withscores 和 limit 同上</td></tr><tr><td>zremrangebyscore key start stop</td><td>根据分数区间进行删除</td></tr><tr><td>zremrangebyrank key start stop</td><td>按照分数排行从小到大的排序删除，从 0 开始计算</td></tr><tr><td>zremrangebylex key min max</td><td>按照值的分布进行删除</td></tr><tr><td>zrevrange key start stop [withscores]</td><td>从大到小的按分数排序</td></tr><tr><td>zrevrangebyscore key max min [withscores]</td><td>从大到小的按分数排序</td></tr><tr><td>zrevrank key member</td><td>按从大到小的顺序，求元素的排行</td></tr><tr><td>zscore key member</td><td>返回成员的分数值</td></tr><tr><td>zunionstore desKey numKeys key1 [key2 key3 key4......]</td><td>求多个有序集合的并集，其中 numKeys 是有序集合的个数</td></tr></tbody></table><h3 id="高级数据类型" tabindex="-1">高级数据类型 <a class="header-anchor" href="#高级数据类型" aria-label="Permalink to &quot;高级数据类型&quot;">​</a></h3><p><strong>BitMap</strong> <br> 一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素</p><ul><li><a href="http://redisdoc.com/bitmap/setbit.html" target="_blank" rel="noreferrer">SETBIT </a>- 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</li><li><a href="http://redisdoc.com/bitmap/getbit.html" target="_blank" rel="noreferrer">GETBIT </a>- 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</li><li><a href="http://redisdoc.com/bitmap/bitcount.html" target="_blank" rel="noreferrer">BITCOUNT </a>- 计算给定字符串中，被设置为 1 的比特位的数量。</li><li><a href="http://redisdoc.com/bitmap/bitpos.html" target="_blank" rel="noreferrer">BITPOS </a></li><li><a href="http://redisdoc.com/bitmap/bitop.html" target="_blank" rel="noreferrer">BITOP </a></li><li><a href="http://redisdoc.com/bitmap/bitfield.html" target="_blank" rel="noreferrer">BITFIELD</a></li></ul><p><strong>HyperLogLog</strong> <br> 统计一个集合中不重复的元素个数，基于概率完成的，标准误算率是 0.81%</p><ul><li><a href="http://redisdoc.com/hyperloglog/pfadd.html" target="_blank" rel="noreferrer">PFADD </a>- 将任意数量的元素添加到指定的 HyperLogLog 里</li><li><a href="http://redisdoc.com/hyperloglog/pfcount.html" target="_blank" rel="noreferrer">PFCOUNT </a>- 返回 HyperLogLog 包含的唯一元素的近似数量。</li><li><a href="http://redisdoc.com/hyperloglog/pfmerge.html" target="_blank" rel="noreferrer">PFMERGE </a>- 将多个 HyperLogLog 合并为一个 HyperLogLog | 命令 | 说明 | | --- | --- | | <a href="http://www.yiibai.com/redis/hyperloglog_pfadd.html" target="_blank" rel="noreferrer">PFADD key element [element …]</a> | 将指定的元素添加到指定的HyperLogLog 中。 | | <a href="http://www.yiibai.com/redis/hyperloglog_pfcount.html" target="_blank" rel="noreferrer">PFCOUNT key [key …]</a> | 返回给定 HyperLogLog 的基数估算值。 | | <a href="http://www.yiibai.com/redis/hyperloglog_pfmerge.html" target="_blank" rel="noreferrer">PFMERGE destkey sourcekey [sourcekey …]</a> | 将多个 HyperLogLog 合并为一个 HyperLogLog |</li></ul><p><strong>GEO</strong></p><ul><li><a href="http://redisdoc.com/geo/geoadd.html" target="_blank" rel="noreferrer">GEOADD </a>- 将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中。</li><li><a href="http://redisdoc.com/geo/geopos.html" target="_blank" rel="noreferrer">GEOPOS </a>- 从 key 里返回所有给定位置元素的位置（经度和纬度）。</li><li><a href="http://redisdoc.com/geo/geodist.html" target="_blank" rel="noreferrer">GEODIST </a>- 返回两个给定位置之间的距离。</li><li><a href="http://redisdoc.com/geo/geohash.html" target="_blank" rel="noreferrer">GEOHASH </a>- 回一个或多个位置元素的标准 Geohash 值</li><li><a href="http://redisdoc.com/geo/georadius.html" target="_blank" rel="noreferrer">GEORADIUS </a></li><li><a href="http://redisdoc.com/geo/georadiusbymember.html" target="_blank" rel="noreferrer">GEORADIUSBYMEMBER</a></li></ul><p><strong>Stream</strong> <br> 为消息队列设计的数据类型 <br> 支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠</p><ul><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li>XLEN ：查询消息长度；</li><li>XREAD：用于读取消息，可以按 ID 读取数据；</li><li>XDEL ： 根据消息 ID 删除消息；</li><li>DEL ：删除整个 Stream；</li><li>XRANGE ：读取区间消息</li><li>XREADGROUP：按消费组形式读取消息；</li><li>XPENDING ：查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li><li>XACK ：向消息队列确认消息处理已完成</li></ul><h3 id="发布订阅" tabindex="-1">发布订阅 <a class="header-anchor" href="#发布订阅" aria-label="Permalink to &quot;发布订阅&quot;">​</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/pub_sub_psubscribe.html" target="_blank" rel="noreferrer">PSUBSCRIBE pattern [pattern …]</a></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td><a href="http://www.yiibai.com/redis/pub_sub_pubsub.html" target="_blank" rel="noreferrer">PUBSUB subcommand [argument [argument …]]</a></td><td>查看订阅与发布系统状态。</td></tr><tr><td><a href="http://www.yiibai.com/redis/pub_sub_publish.html" target="_blank" rel="noreferrer">PUBLISH channel message</a></td><td>将信息发送到指定的频道。</td></tr><tr><td><a href="http://www.yiibai.com/redis/pub_sub_punsubscribe.html" target="_blank" rel="noreferrer">PUNSUBSCRIBE [pattern [pattern …]]</a></td><td>退订所有给定模式的频道。</td></tr><tr><td><a href="http://www.yiibai.com/redis/pub_sub_subscribe.html" target="_blank" rel="noreferrer">SUBSCRIBE channel [channel …]</a></td><td>订阅给定的一个或多个频道的信息。</td></tr><tr><td><a href="http://www.yiibai.com/redis/pub_sub_unsubscribe.html" target="_blank" rel="noreferrer">UNSUBSCRIBE [channel [channel …]]</a></td><td>退订给定的频道。</td></tr></tbody></table><h3 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h3><p>Redis 提供的不是严格的事务，只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/transactions_discard.html" target="_blank" rel="noreferrer">DISCARD</a></td><td>丢弃在MULTI之后发出的所有命令</td></tr><tr><td><a href="http://www.yiibai.com/redis/transactions_exec.html" target="_blank" rel="noreferrer">EXEC</a></td><td>执行MULTI后发出的所有命令</td></tr><tr><td><a href="http://www.yiibai.com/redis/transactions_multi.html" target="_blank" rel="noreferrer">MULTI</a></td><td>标记事务块的开始</td></tr><tr><td><a href="http://www.yiibai.com/redis/transactions_unwatch.html" target="_blank" rel="noreferrer">UNWATCH</a></td><td>取消 WATCH 命令对所有 key 的监视。</td></tr><tr><td><a href="http://www.yiibai.com/redis/transactions_watch.html" target="_blank" rel="noreferrer">WATCH key [key …]</a></td><td>监视给定的键以确定MULTI / EXEC块的执行</td></tr></tbody></table><h3 id="时限" tabindex="-1">时限 <a class="header-anchor" href="#时限" aria-label="Permalink to &quot;时限&quot;">​</a></h3><table><thead><tr><th>命 令</th><th>说 明</th><th>备 注</th></tr></thead><tbody><tr><td>persist key</td><td>持久化 key，取消超时时间</td><td>移除 key 的超时时间</td></tr><tr><td>ttl key</td><td>査看 key 的超时时间</td><td>以秒计算，-1 代表没有超时时间，如果不存在 key 或者 key 已经超时则为 -2</td></tr><tr><td>expire key seconds</td><td>设置超时时间戳</td><td>以秒为单位</td></tr><tr><td>expireat key timestamp</td><td>设置超时时间点</td><td>用 uninx 时间戳确定</td></tr><tr><td>pptl key milliseconds</td><td>查看key的超时时间戳</td><td>用亳秒计算</td></tr><tr><td>pexpire key</td><td>设置键值超时的时间</td><td>以亳秒为单位</td></tr><tr><td>Pexpireat key stamptimes</td><td>设置超时时间点</td><td>以亳秒为单位的 uninx 时间戳</td></tr></tbody></table><h3 id="脚本" tabindex="-1">脚本 <a class="header-anchor" href="#脚本" aria-label="Permalink to &quot;脚本&quot;">​</a></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/scripting_eval.html" target="_blank" rel="noreferrer">EVAL script numkeys key [key …] arg [arg …]</a></td><td>执行一个Lua脚本。</td></tr><tr><td><a href="http://www.yiibai.com/redis/scripting_evalsha.html" target="_blank" rel="noreferrer">EVALSHA sha1 numkeys key [key …] arg [arg …]</a></td><td>执行一个Lua脚本。</td></tr><tr><td><a href="http://www.yiibai.com/redis/scripting_script_exists.html" target="_blank" rel="noreferrer">SCRIPT EXISTS script [script …]</a></td><td>检查脚本缓存中是否存在脚本。</td></tr><tr><td><a href="http://www.yiibai.com/redis/scripting_script_flush.html" target="_blank" rel="noreferrer">SCRIPT FLUSH</a></td><td>从脚本缓存中删除所有脚本。</td></tr><tr><td><a href="http://www.yiibai.com/redis/scripting_script_kill.html" target="_blank" rel="noreferrer">SCRIPT KILL</a></td><td>杀死当前正在执行的脚本。</td></tr><tr><td><a href="http://www.yiibai.com/redis/scripting_script_load.html" target="_blank" rel="noreferrer">SCRIPT LOAD script</a></td><td>将指定的Lua脚本加载到脚本缓存中。</td></tr></tbody></table><p><strong>服务器</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/server_bgrewriteaof.html" target="_blank" rel="noreferrer">BGREWRITEAOF</a></td><td>异步重写仅追加的文件</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_bgsave.html" target="_blank" rel="noreferrer">BGSAVE</a></td><td>将数据集异步保存到磁盘</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_cluster_slots.html" target="_blank" rel="noreferrer">CLUSTER SLOTS</a></td><td>获取群集插槽到节点映射的数组</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_command.html" target="_blank" rel="noreferrer">COMMAND</a></td><td>获取Redis命令详细信息的数组</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_command_count.html" target="_blank" rel="noreferrer">COMMAND COUNT</a></td><td>获取Redis命令的总数</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_command_getkeys.html" target="_blank" rel="noreferrer">COMMAND GETKEYS</a></td><td>提取键给出一个完整的Redis的命令</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_command_info.html" target="_blank" rel="noreferrer">COMMAND INFO command-name [command-name …]</a></td><td>获取特定Redis命令详细信息的数组</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_config_get.html" target="_blank" rel="noreferrer">CONFIG GET parameter</a></td><td>获取配置参数的值</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_config_rewrite.html" target="_blank" rel="noreferrer">CONFIG REWRITE</a></td><td>使用内存中配置来重写配置文件</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_config_set.html" target="_blank" rel="noreferrer">CONFIG SET parameter value</a></td><td>将配置参数设置为给定值</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_config_resetstat.html" target="_blank" rel="noreferrer">CONFIG RESETSTAT</a></td><td>重置由INFO返回的统计信息</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_dbsize.html" target="_blank" rel="noreferrer">DBSIZE</a></td><td>返回所选数据库中的键数量</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_debug_object.html" target="_blank" rel="noreferrer">DEBUG OBJECT key</a></td><td>获取有关键的调试信息</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_debug_segfault.html" target="_blank" rel="noreferrer">DEBUG SEGFAULT</a></td><td>使服务器崩溃</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_flushall.html" target="_blank" rel="noreferrer">FLUSHALL</a></td><td>从所有数据库中删除所有键</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_flushdb.html" target="_blank" rel="noreferrer">FLUSHDB</a></td><td>删除当前数据库中的所有键</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_info.html" target="_blank" rel="noreferrer">INFO [section]</a></td><td>获取有关服务器的信息和统计信息</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_lastsave.html" target="_blank" rel="noreferrer">LASTSAVE</a></td><td>获取上次成功保存到磁盘的UNIX时间戳</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_monitor.html" target="_blank" rel="noreferrer">MONITOR</a></td><td>监听服务器实时接收的所有请求</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_role.html" target="_blank" rel="noreferrer">ROLE</a></td><td>返回实例在复制上下文中的角色</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_save.html" target="_blank" rel="noreferrer">SAVE</a></td><td>将数据集同步保存到磁盘，在 redis 安装目录中创建dump.rdb文件</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_shutdown.html" target="_blank" rel="noreferrer">SHUTDOWN [NOSAVE] [SAVE]</a></td><td>将数据集同步保存到磁盘，然后关闭服务器</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_slaveof.html" target="_blank" rel="noreferrer">SLAVEOF host port</a></td><td>使服务器成为另一个实例的从属，或将其提升作为主服务器</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_showlog.html" target="_blank" rel="noreferrer">SLOWLOG subcommand [argument]</a></td><td>管理Redis慢查询日志</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_sync.html" target="_blank" rel="noreferrer">SYNC</a></td><td>用于复制的命令</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_time.html" target="_blank" rel="noreferrer">TIME</a></td><td>返回当前服务器的时间</td></tr></tbody></table><p>info [section]：查询 Redis 相关信息</p><ul><li>server: Redis server 的常规信息</li><li>clients: Client 的连接选项</li><li>memory: 存储占用相关信息</li><li>persistence: RDB and AOF 相关信息</li><li>stats: 常规统计</li><li>replication: Master/Slave 请求信息</li><li>cpu: CPU 占用信息统计</li><li>cluster: Redis 集群信息</li><li>keyspace: 数据库信息统计</li><li>all: 返回所有信息</li><li>default: 返回常规设置信息</li></ul><h3 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-label="Permalink to &quot;客户端&quot;">​</a></h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.yiibai.com/redis/server_client_kill.html" target="_blank" rel="noreferrer">CLIENT KILL [ip:port] [ID client-id]</a></td><td>杀死或断开指定的客户端的连接</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_client_list.html" target="_blank" rel="noreferrer">CLIENT LIST</a></td><td>获取到服务器的客户端连接列表</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_client_getname.html" target="_blank" rel="noreferrer">CLIENT GETNAME</a></td><td>获取当前连接的名称</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_client_pause.html" target="_blank" rel="noreferrer">CLIENT PAUSE timeout</a></td><td>在指定时间内停止处理来自客户端的命令</td></tr><tr><td><a href="http://www.yiibai.com/redis/server_client_setname.html" target="_blank" rel="noreferrer">CLIENT SETNAME connection-name</a></td><td>设置当前连接名称</td></tr></tbody></table><h2 id="持久化-备份" tabindex="-1">持久化 | 备份 <a class="header-anchor" href="#持久化-备份" aria-label="Permalink to &quot;持久化 | 备份&quot;">​</a></h2><ul><li>快照方式（RDB）：将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中</li><li>只追加文件（Append-Only File，AOF）：以文本日志形式将所有写命令追加到 AOF 文件的末尾，以此来记录数据的变化。当服务器重启的时候会重新载入和执行这些命令来恢复原始的数据</li></ul><h2 id="分布式" tabindex="-1">分布式 <a class="header-anchor" href="#分布式" aria-label="Permalink to &quot;分布式&quot;">​</a></h2><p>哨兵（Sentinel）：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><ul><li>监控（Monitoring） - 不断检查主从服务器是否正常在工作。</li><li>通知（Notification） - 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li><li>自动故障转移（Automatic Failover） - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li><li>配置提供者（Configuration provider） - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li></ul><h2 id="resource" tabindex="-1">Resource <a class="header-anchor" href="#resource" aria-label="Permalink to &quot;Resource&quot;">​</a></h2><ul><li><a href="http://redisdoc.com/" target="_blank" rel="noreferrer">Redis 命令参考</a></li><li><a href="https://github.com/JamzyWang/awesome-redis" target="_blank" rel="noreferrer">awesome-redis</a></li></ul><p>Java Redis Client</p><ul><li><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noreferrer">jedis</a> - 最流行的 Redis Java 客户端</li><li><a href="https://github.com/redisson/redisson" target="_blank" rel="noreferrer">redisson </a>- 额外提供了很多的分布式服务特性，如：分布式锁、分布式 Java 常用对象</li><li><a href="https://github.com/lettuce-io/lettuce-core" target="_blank" rel="noreferrer">lettuce </a>- Spring Boot 2.0 默认 Redis 客户端</li></ul><h2 id="——-mongodb-——" tabindex="-1">—— MongoDB —— <a class="header-anchor" href="#——-mongodb-——" aria-label="Permalink to &quot;—— MongoDB ——&quot;">​</a></h2><p><a href="https://www.mongodb.com/" target="_blank" rel="noreferrer">mongodb</a>由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 <br> 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>面向集合存储，易于存储对象类型的数据，模式自由，支持动态查询，支持完全索引，支持复制和故障恢复，使用高效的二进制数据存储，文件存储格式为 BSON （ 一种 JSON 的扩展）等。</p><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td>不支持</td><td>表连接</td></tr><tr><td>primary key</td><td>primary key</td><td>主键</td></tr></tbody></table>',71),l=[i];function o(s,h,n,b,m,w){return r(),e("div",null,l)}const y=t(d,[["render",o]]);export{f as __pageData,y as default};
